# 톱니바퀴
# 8개의 톱니를 가진 톱니바퀴 4개가 일렬로
    # 톱니는 n극 / s극 중 하나
    # 톱니바퀴에는 번호 (1,2,3,4 순)
# 톱니바퀴를 총 k번 시계/반시계 회전(1칸 기준)
# 회전시킬 톱니바퀴와 회전시킬 방향을 결정
    # A회전시, A,B의 맞닿은 톱니의 극이 다름 => B : A의 반대방향을 회전
    # A회전시, A,B의 맞닿은 톱니의 극이 같음 => B : 회전 X
    # 회전하지 않는다면, B또한 회전X
# 톱니바퀴 초기상태, 회전 방법 => 최종 톱니바퀴의 상태

# 입력 : 4줄에 걸쳐 1,2,3,4번 톱니바퀴의 상태(8개 정수, 12시부터 시계방향, n극0 / s극 1)
# 회전 횟수 k(1~100)
# k개 줄에 회전 시킨 방법 : 회전시킨 톱니바퀴 번호, 방향(1시계 / -1반시계) 
# 출력 : k번 회전시킨 후 4 톱니바퀴의 점수 합 출력
    # 12시 방향 기준 (0번 인덱스)
    # 1번 : s극 1점
    # 2번 : s극 2점
    # 3번 : s극 4점
    # 4번 : s극 8점

wheel = [[]]
for _ in range(4):
    wheel.append(list(map(int,input().rstrip())))
k = int(input())
counter = [0]*4


# 바퀴 회전 함수
def rotateWheel(w,dir):
    # 시계방향 회전
    if dir == 1:
        w[0],w[1],w[2],w[3],w[4],w[5],w[6],w[7] = w[7],w[0],w[1],w[2],w[3],w[4],w[5],w[6]
    # 반시계방향 회전
    else:
        w[0],w[1],w[2],w[3],w[4],w[5],w[6],w[7] = w[1],w[2],w[3],w[4],w[5],w[6],w[7],w[0]


# 회전시키기
for _ in range(k):
    # 맞닿은 면의 극 확인하기
    for i in range(1,4):
        if wheel[i][2] == wheel[i+1][6]:
            counter[i] = 0
        else:
            counter[i] = 1
    # 바퀴와 방향 입력
    num, dir = map(int,input().split())
    # 바퀴 회전
    rotateWheel(wheel[num],dir)
    # 주변 바퀴 회전
    n, d = num, dir
    while n > 1 and counter[n-1]:
        rotateWheel(wheel[n-1],-d)
        n -= 1
        d = -d
    n, d = num, dir
    while n < 4 and counter[n]:
        rotateWheel(wheel[n+1],-d)
        n += 1
        d = -d

print(1*wheel[1][0] + 2*wheel[2][0] + 4*wheel[3][0] + 8*wheel[4][0])


# 10101111
# 01111101
# 11001110
# 00000010
# 2
# 3 -1
# 1 1             # 7

# 11111111
# 11111111
# 11111111
# 11111111
# 3
# 1 1
# 2 1
# 3 1             # 15

# 10001011
# 10000011
# 01011011
# 00111101
# 5
# 1 1
# 2 1
# 3 1
# 4 1
# 1 -1            # 6

# 10010011
# 01010011
# 11100011
# 01010101
# 8
# 1 1
# 2 1
# 3 1
# 4 1
# 1 -1
# 2 -1
# 3 -1
# 4 -1            # 5